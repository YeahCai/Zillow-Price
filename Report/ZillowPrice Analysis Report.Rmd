---
title: "ZillowPrice Report"
author: "Ye Cai"
date: "7/19/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


```{r}
library(data.table)
library(dplyr)
library(ggplot2)
library(stringr)
library(DT)
library(tidyr)
library(corrplot)
library(leaflet)
library(lubridate)
library(tidytext)
library(readr)
library(forcats)  #used for reordering
library(htmltools) #used for HTML 
```


```{r}
### Load Data
propertiesTrain <- read_csv("properties_2016.csv")
transactionsTrain <- read_csv("train_2016_v2.csv")
```

```{r}
### Glimpse of the "transaction"
## Distibution of transaction dates in "transaction"
View(transactionsTrain)
#since I just focus on Year_Month analysis, I need to extract the year and month information
#it's just on 2016, now create another new column, "month" to order the months chronologically
transactionsTrainNew <- transactionsTrain %>% 
  mutate(
  Year_Month = paste(month.abb[as.numeric(month(transactionsTrain$transactiondate))],
                     year(transactionsTrain$transactiondate), sep = " "),
  Month = factor(month.abb[as.numeric(month(transactionsTrain$transactiondate))])
  #YearMonth =as.numeric(paste(year(transactionsTrain$transactiondate),month(transactionsTrain$transactiondate),sep = ""))
)
transactionsTrainNew %>%
  group_by(Month) %>%
  ggplot(aes(x=Month))+ # add `` here to solve problem
  geom_bar(stat = "count", fill="#FF6666")+
  scale_x_discrete(limits = month.abb)+
  #geom_vline(aes(xintercept=which(transactionsTrain$transactiondate=="2016-10-01")))+
  annotate("text",x="Oct",y=6000, label="Prediction Area")+
  theme(axis.text.x = element_text(angle=45,hjust=1)) +
  ggtitle("The sum of transaction in every month on 2016")+
  xlab("2016_Month")+
  ylab("Total of Transactions")
```


```{r}
##Distribution of the difference of logerror in "transaction"
transactionsTrainNew %>%
  ggplot(aes(x=logerror)) +
  geom_histogram(bins = 500,fill="red")+
  theme(axis.text.x = element_text(angle=45,hjust=1))+
  theme_bw()+
  coord_cartesian(x=c(-0.5,0.5))+ # the range of x axis
  ggtitle("The count of logerror on 2016")+
  xlab("Logerror")+
  ylab("Count")
#We could conclude that most logerror is relatively close to zero which means their 
#prediction is good. A positive logerror means Zestimate is overestimated while a
#negative one is underestimated.
```


```{r}
##Distribution of the difference of absolute logerror'
transactionsTrainNew %>%
  mutate(abs_logerror=abs(logerror)) %>%
  ggplot(aes(x=abs_logerror))+
  geom_histogram(bins = 500,fill="red")+
  theme(axis.text.x = element_text(angle=45,hjust=1))+
  theme_bw()+
  coord_cartesian(x=c(0,0.5))+
  ggtitle("The count of Absolute logerror on 2016")+
  xlab("Absolute Logerror")+
  ylab("Count")
```

```{r}
##The trend of logerror changed over time
#It's the trend of the mean of logerror
transactionsTrainNew %>%
  group_by(Month) %>% 
  summarise(mean_logerror=mean(logerror)) %>%
  ggplot(aes(x=Month,y=mean_logerror,group=1))+
  scale_x_discrete(limits = month.abb)+
  geom_line(size=2,color="red")+
  geom_point(size=4,color="red")+
  theme_bw()+
  ggtitle("The count of mean logerror on 2016")+
  xlab("Absolute Logerror")+
  ylab("Count")
```

```{r}
#It's the trend of the mean of absolute logerror
transactionsTrainNew %>%
  mutate(abs_logerror=abs(logerror)) %>%
  group_by(Month) %>%  
  summarise(mean_absolute_logerror = mean(abs_logerror)) %>%
  ggplot(aes(x=Month,y=mean_absolute_logerror,group=1))+
  scale_x_discrete(limits = month.abb)+
  geom_line(size=2,color="red")+
  geom_point(size=4,color="red")+
  theme_bw()+
  ggtitle("The count of the mean od Absolute logerror on 2016")+
  xlab("Absolute Logerror")+
  ylab("Count")
#since "group_by(Month)" divides all obversations into 12 groups, "geom_line"
#can not connect all points together. Using "group=1" to change the default value.

```

```{r}
### Glimpse of the "propertiesTrain"
str(propertiesTrain)

##deal with some Boolean columns in "propertiesTrain"
unique(propertiesTrain$fireplaceflag)
unique(propertiesTrain$taxdelinquencyflag)
#I need to change those two columns with numeric type, 1 or 0
propertiesTrainNew <- propertiesTrain %>%
  mutate(fireplaceflag = ifelse(fireplaceflag==TRUE,1,0),
         taxdelinquencyflag = ifelse(taxdelinquencyflag=="Y",1,0))

```

```{r}
##Show the percentage of missing value in different features 
require(data.table)
require(graphics)
#define the function to calculate the percentage
definefunction <- function(x){
  (sum(is.na(x))/length(x))
}

#
data.table(
  pmiss = as.numeric(format(round(100*sapply(propertiesTrainNew, definefunction),2),nsmall = 2)),
  column=names(propertiesTrainNew)
) %>%
  ggplot(aes(x=reorder(column,-pmiss),y=pmiss))+
  geom_bar(stat = "identity",fill="orange")+
  geom_text(aes(label=pmiss),vjust=1.5,colour="black")+
  scale_y_continuous(labels = scales::percent)+
  theme(axis.text.x = element_text(angle = 50,hjust = 2))+
  labs(
    title = "The Percent of Missing value Grouped by Features",
    x = "Feature",
    y = "The Percent of Missing Value"
  )+
  coord_flip()
#
#reorder() can only deal with numeric verctor, the below code, I add paste0() which change

```


```{r}
#if there are so many missing values, it means this column could not provide useful information
#in the final model. Therefore, deleting those columns
propertiesTrainNew_goodfeatures <- propertiesTrainNew %>%
  summarise_each(funs(sum(is.na(.))/n())) %>% #n(): the number of obversations in the current group
  gather(key = "feature",value = "pmiss") %>% #key,value: names of new key and value
  filter(pmiss < .75)
#summarise_each is another alternative approach to summarise()
#summarise_each(funs(X),x), X means different functions defined by yourselves or others.
#x means column
goodfeatures <- as.matrix(propertiesTrainNew_goodfeatures %>%
  select(feature))

```


```{r}

###Combine "propertiesTrainNew" and "transactionsTrainNew" together by left-join
TransactProperties <-transactionsTrainNew %>%
  mutate(abs_logerror=abs(logerror)) %>%  #add a new column, the absolute value of logerror
  left_join(propertiesTrainNew,by="parcelid")

##Show the difference in error between the building-quality types
TransactProperties %>%
  ggplot(aes(x=as.factor(buildingqualitytypeid), y=logerror)) +
  geom_jitter(alpha=0.5,color="lightgrey") +
  geom_boxplot(color="blue",outlier.colour = NA)
```


```{r}
##Correlation with absolute logerror in "propertiesTrainNew"
#I just focus on numeric ones

#since there aere 63 columns in "TransactProperties", we firstly need to select 33 good features,
#and then choose numeric ones from those 33 features to make a correlation plot
TransactPropertiesAllGoodFeature <- TransactProperties %>%
  select(c(goodfeatures,"abs_logerror","logerror","Year_Month"))
#Keep numeric columns from the above data frame
index <- unlist(lapply(TransactPropertiesAllGoodFeature,is.numeric))
TransactPropertiesNumericFeature <- TransactPropertiesAllGoodFeature[,index]

```


```{r}
###Correlation plot based on "absolute logerror"
##Focus on the correlation between the number of bathroom, bedroom, garage, room, unit and absolute logerror
TransactPropertiesNumericFeatureChosen_num <- TransactPropertiesNumericFeature %>% 
  select(one_of(c("abs_logerror","bathroomcnt","bedroomcnt","calculatedbathnbr",
                  "fullbathcnt","garagecarcnt","roomcnt","unitcnt")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_num, use="complete.obs"),type="lower")

##Focus on the correlation between "area" features and absolute logerror
TransactPropertiesNumericFeatureChosen_area <- TransactPropertiesNumericFeature %>%
  select(one_of(c("abs_logerror","calculatedfinishedsquarefeet","finishedsquarefeet12",
                  "garagetotalsqft","lotsizesquarefeet")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_area, use="complete.obs"),type="lower")

##Focus on the correlation between "tax" features and absolute logerror
TransactPropertiesNumericFeatureChosen_tax <- TransactPropertiesNumericFeature %>%
  select(one_of(c("abs_logerror","structuretaxvaluedollarcnt","taxvaluedollarcnt"
                  ,"landtaxvaluedollarcnt","taxamount")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_tax, use="complete.obs"),type="lower")

###Correlation plot based on "logerror" (not same as before three plots)
#the number of rooms
TransactPropertiesNumericFeatureChosen_num1 <- TransactPropertiesNumericFeature %>% 
  select(one_of(c("logerror","bathroomcnt","bedroomcnt","calculatedbathnbr",
                  "fullbathcnt","garagecarcnt","roomcnt","unitcnt")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_num1, use="complete.obs"),type="lower")
#"area" features
TransactPropertiesNumericFeatureChosen_area1 <- TransactPropertiesNumericFeature %>%
  select(one_of(c("logerror","calculatedfinishedsquarefeet","finishedsquarefeet12",
                  "garagetotalsqft","lotsizesquarefeet")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_area1, use="complete.obs"),type="lower")
#"tax" features
TransactPropertiesNumericFeatureChosen_tax1 <- TransactPropertiesNumericFeature %>%
  select(one_of(c("logerror","structuretaxvaluedollarcnt","taxvaluedollarcnt"
                  ,"landtaxvaluedollarcnt","taxamount")))
corrplot(cor(TransactPropertiesNumericFeatureChosen_tax1, use="complete.obs"),type="lower")
##Conclusion: the prediction is very good
```


```{r}
###The year of houses built
TransactPropertiesNumericFeature %>%
  ggplot(aes(x=yearbuilt)) +
  geom_line(stat = "density",color="dark green") +
  labs(
    title = "The year of houses built",
    x = "Year",
    y = "Density"
  )+
  theme_bw()
#The total sum of density is equal to 1.
#Most houses were built after 1950.

###The trend of absolute logerror changed with the year of house built
TransactPropertiesNumericFeature %>%
  group_by(yearbuilt) %>%
  summarize(mean_abs_logerror= mean(abs(logerror),n())) %>%
  ggplot(aes(x=yearbuilt,y=mean_abs_logerror)) +
  geom_smooth(color="grey40") +
  geom_point(color="red") +
  coord_cartesian(y=c(0,0.3))+
  theme_bw()
##Conclusion: The prediction after 1950 is good and improved a lot after 1950.

```


```{r}
###Where Zestimate predict well?
##Divide the percentiles into three parts, best predictions(top 10%), worst predictions(worst 10%),
#typical predictions(50% around the median)
transactionsTrainNew1 <- transactionsTrainNew %>% 
  mutate(abs_logerror = abs(logerror))
transactionsTrainNew_Percentile <- transactionsTrainNew1 %>%
  mutate(percentile = cut(abs_logerror, quantile(abs_logerror, 
                                                probs = c(0, .1,.25,.75,.9,1),
                                                names=FALSE), include.lowest = TRUE, labels = FALSE ))
#divide into five classes
#create three subset data frame
TransactProperties_percentile1 <- transactionsTrainNew_Percentile %>%
  filter(percentile == 1) %>%
  mutate(type = "best_predicton") %>%
  left_join(propertiesTrainNew,by="parcelid")
#percentile 1
TransactProperties_percentile2 <- transactionsTrainNew_Percentile %>%
  filter(percentile == 5) %>%
  mutate(type = "worst_prediction") %>%
  left_join(propertiesTrainNew,by="parcelid")
#percentile 2
TransactProperties_percentile3 <- transactionsTrainNew_Percentile %>%
  filter(percentile == 3) %>%
  mutate(type = "typical_prediction") %>%
  left_join(propertiesTrainNew,by="parcelid")
#percentile 3
unique(TransactProperties_percentile1$percentile)  #double check the result

TransactProperties_Allpercentile <- bind_rows(TransactProperties_percentile1,
                                              TransactProperties_percentile2,
                                              TransactProperties_percentile3) %>%
  mutate(type = factor(type, levels = c("best_predicton",
                                               "worst_prediction",
                                               "typical_prediction")),
         ClassOfType = as.numeric(type)
         )
```


```{r}
##Focus on the relationship between all-finished-area 
#Based on different prediction class
TransactProperties_Allpercentile %>%
  ggplot(aes(x=finishedsquarefeet15, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on total-finished-area",
    x = "Total Finished Area",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(700,7.5e3))
#Based on absolute logerror
TransactProperties_Allpercentile %>%
  ggplot(aes(x=finishedsquarefeet15,y=abs_logerror)) +
  geom_smooth(color = "red") + # show the overlapping points and then find a trend by using defaulting function LS
  theme_bw() +
  labs(
    title = "The distribution of Absolute Logerror based on total-finished-area",
    x = "Total Finished Area",
    y = "Absolute Logerror"
  ) +
  coord_cartesian(xlim=c(600,7.5e3),ylim=c(0.1,0.2))

##Focus on the relationship between finished-lived-area
#Based on different prediction class
TransactProperties_Allpercentile %>%
  ggplot(aes(x=finishedsquarefeet12, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on finished-lived-area",
    x = "Finished lived Area",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(0,1e4))

##Focus on the number of rooms
TransactProperties_Allpercentile %>%
  ggplot(aes(x=roomcnt, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on the number of rooms",
    x = "The Number of Room",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(0,10))

##Focus on the number of units
TransactProperties_Allpercentile %>%
  ggplot(aes(x=unitcnt, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on the number of units",
    x = "The Number of Unit",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(1,4))

```


```{r}
##Focus on different year
TransactProperties_Allpercentile %>%
  ggplot(aes(x=yearbuilt, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on different year",
    x = "Different Year",
    y = "Density"
  ) 

##Focus on total sum of tax
#Based on different prediction class
TransactProperties_Allpercentile %>%
  ggplot(aes(x=taxvaluedollarcnt, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on total-sum-tax",
    x = "Total Sum of Tax",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(0,1e6))
#Based on absolute logerror
TransactProperties_Allpercentile %>%
  ggplot(aes(x=taxvaluedollarcnt,y=abs_logerror)) +
  geom_smooth(color = "red") + # show the overlapping points and then find a trend by using defaulting function LS
  theme_bw() +
  labs(
    title = "The distribution of Absolute Logerror based on total-sum-tax",
    x = "Total Sum of Tax",
    y = "Absolute Logerror"
  ) +
  coord_cartesian(xlim=c(0,1e6),ylim=c(0.05,0.2))

##Focus on the assessed value of the house
TransactProperties_Allpercentile %>%
  ggplot(aes(x=structuretaxvaluedollarcnt, fill=type, color=type)) +
  geom_line(stat = "density", size = 1.2) +
  theme_bw() +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "The distribution of three prediction class based on the Assessed value of the House",
    x = "The Assessed Value of the House",
    y = "Density"
  ) +
  coord_cartesian(xlim=c(0,1e6))


###Where does Zestimate Overpredict or Underpredict???
##As I mentioned before, if logerror < 0, it is underpredicting, otherwise.
TransactProperties_Allpercentile_OverUnder <- TransactProperties_Allpercentile %>%
  mutate(OverUnder = ifelse(logerror < 0, "Underprediction", "Overprediction"))

##Focus on area
TransactProperties_Allpercentile_OverUnder %>%
  ggplot(aes(x=latitude,y=abs_logerror,color=OverUnder)) +
  geom_smooth() +
  theme_bw() +
  scale_color_brewer(palette="Set1") +
  labs(
    title = "The distribution of Overprediction/Underprediction based on different latitude",
    x = "latitude",
    y = "Absolute Logerror"
  )

TransactProperties_Allpercentile_OverUnder %>%
  ggplot(aes(x=longitude,y=abs_logerror,color=OverUnder)) +
  geom_smooth() +
  theme_bw() +
  scale_color_brewer(palette="Set1") +
  labs(
    title = "The distribution of Overprediction/Underprediction based on different longitude",
    x = "longitude",
    y = "Absolute Logerror"
  )
```

```{r}
###Mapping
Latitude <- range(TransactProperties_Allpercentile_OverUnder$latitude/1e06,na.rm = TRUE)
Longitude <- range(TransactProperties_Allpercentile_OverUnder$longitude/1e06,na.rm = TRUE)  
#I know the range of mapping
 TransactProperties_Mapping <- propertiesTrainNew%>%
   sample_n(20000) %>%
   select(parcelid,longitude,latitude) %>%
   mutate(Longitude=longitude/1e6, Latitude=latitude/1e6) %>%
   select(parcelid,Latitude,Longitude) %>%
   left_join(transactionsTrainNew, by="parcelid")
#Where are those properties???
leaflet(TransactProperties_Mapping) %>%
   addTiles() %>% #Add default OpenStreetMap map tiles
   fitBounds(Longitude[1],Latitude[1],Longitude[2],Latitude[2]) %>% # the bound of map
   addCircleMarkers(stroke = FALSE) %>% #add circle markers to the map
   addMiniMap()
```

```{r}
##Mapping 
TransactProperties_Mapping_Abslogerror <- transactionsTrainNew1 %>%
  sample_n(2000) %>%
  left_join(propertiesTrainNew, by="parcelid") %>%
  select(parcelid,longitude,latitude,abs_logerror) %>%
  mutate(lon=longitude/1e6, lat=latitude/1e6) %>%
  select(parcelid,lon,lat,abs_logerror)
#define the color of markers
qpal <- colorQuantile("YlOrRd", TransactProperties_Mapping_Abslogerror$abs_logerror,n=7)
#mapping
leaflet(TransactProperties_Mapping_Abslogerror) %>%
  addTiles() %>%
  #fitBounds(lon[1],lat[1],lon[2],lat[2]) %>%
  addCircleMarkers(stroke = FALSE, color = ~qpal(abs_logerror),fillOpacity = 1) %>%
  addLegend("bottomright",pal = qpal, values = ~abs_logerror,title = "Absolute Logerror",
            opacity = 1) %>%
  addMiniMap()
```

```{r}
##Geographic Features about some specific information related to every house
#[row,column]
TransactProperties_Mapping1 <- propertiesTrainNew%>%
  sample_n(20000) %>%
  select(parcelid,longitude,latitude,bedroomcnt,bathroomcnt,finishedsquarefeet15) %>%
  mutate(Lon=longitude/1e6, Lat=latitude/1e6) %>%
  select(parcelid,Lat,Lon,bedroomcnt,bathroomcnt,finishedsquarefeet15) %>%
  left_join(transactionsTrainNew, by="parcelid") 

myLabel <- paste(sep = "<br>",
        paste("Bedrooms:",TransactProperties_Mapping1$bedroomcnt),
        paste("Bathrooms:",TransactProperties_Mapping1$bathroomcnt),
        paste("Total area:",TransactProperties_Mapping1$finishedsquarefeet15))


leaflet(TransactProperties_Mapping1) %>%
  addTiles() %>%
  addCircleMarkers(
    lat = ~Lat,
    lng = ~Lon,
    label = ~HTML(myLabel),
    clusterOptions = markerClusterOptions()
  )

```



